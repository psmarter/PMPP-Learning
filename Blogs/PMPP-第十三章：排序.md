---
title: PMPP-ç¬¬åä¸‰ç« ï¼šæ’åº
tags:
  - CUDA
  - GPUç¼–ç¨‹
  - å¹¶è¡Œè®¡ç®—
  - PMPP
  - æ’åº
  - åŸºæ•°æ’åº
  - å½’å¹¶æ’åº
categories: çŸ¥è¯†åˆ†äº«
cover: /img/PMPP.jpg
abbrlink: d9ee9484
date: 2026-01-18 22:04:20
---

## å‰è¨€

å‰ä¸¤ç« å­¦ä¹ äº†å½’çº¦å’Œå½’å¹¶ï¼Œæœ¬ç« å­¦ä¹ **æ’åºï¼ˆSortingï¼‰**â€”â€”æŠŠæ— åºæ•°æ®å˜æˆæœ‰åºæ•°æ®ã€‚æ’åºæ˜¯æœ€åŸºç¡€çš„ç®—æ³•ä¹‹ä¸€ï¼Œåœ¨å‡ ä¹æ‰€æœ‰è®¡ç®—é¢†åŸŸéƒ½æœ‰åº”ç”¨ã€‚GPU æ’åºçš„æŒ‘æˆ˜åœ¨äºï¼šä¼ ç»Ÿæ’åºç®—æ³•ï¼ˆå¦‚å¿«é€Ÿæ’åºï¼‰çš„é€’å½’ç»“æ„å’Œæ•°æ®ä¾èµ–ä¸é€‚åˆ GPU çš„ SIMT æ¨¡å‹ã€‚ç¬¬åä¸‰ç« ä»‹ç»é€‚åˆ GPU çš„æ’åºç®—æ³•ï¼Œé‡ç‚¹æ˜¯**åŸºæ•°æ’åºï¼ˆRadix Sortï¼‰**â€”â€”é€šè¿‡å‰ç¼€å’Œå®ç°é«˜æ•ˆå¹¶è¡Œæ’åºã€‚

> **ğŸ“¦ é…å¥—èµ„æº**ï¼šæœ¬ç³»åˆ—æ–‡ç« é…æœ‰å®Œæ•´çš„ [GitHub ä»“åº“](https://github.com/psmarter/PMPP-Learning)ï¼ŒåŒ…å«æ¯ç« çš„ç»ƒä¹ é¢˜è§£ç­”ã€CUDA ä»£ç å®ç°å’Œè¯¦ç»†æ³¨é‡Šã€‚æ‰€æœ‰ä»£ç éƒ½ç»è¿‡æµ‹è¯•ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œã€‚

## æ’åºç®—æ³•æ¦‚è§ˆ

### åŸºäºæ¯”è¾ƒçš„æ’åº

| ç®—æ³•     | å¹³å‡å¤æ‚åº¦ | æœ€åå¤æ‚åº¦ | ç©ºé—´     | ç¨³å®šæ€§ |
| -------- | ---------- | ---------- | -------- | ------ |
| å†’æ³¡æ’åº | O(nÂ²)      | O(nÂ²)      | O(1)     | ç¨³å®š   |
| æ’å…¥æ’åº | O(nÂ²)      | O(nÂ²)      | O(1)     | ç¨³å®š   |
| å¿«é€Ÿæ’åº | O(n log n) | O(nÂ²)      | O(log n) | ä¸ç¨³å®š |
| å½’å¹¶æ’åº | O(n log n) | O(n log n) | O(n)     | ç¨³å®š   |
| å †æ’åº   | O(n log n) | O(n log n) | O(1)     | ä¸ç¨³å®š |

**ç†è®ºä¸‹ç•Œ**ï¼šåŸºäºæ¯”è¾ƒçš„æ’åºæœ€ä¼˜æ˜¯ O(n log n)ã€‚

### éæ¯”è¾ƒæ’åº

| ç®—æ³•     | å¤æ‚åº¦      | é€‚ç”¨ç±»å‹     |
| -------- | ----------- | ------------ |
| è®¡æ•°æ’åº | O(n + k)    | å°èŒƒå›´æ•´æ•°   |
| åŸºæ•°æ’åº | O(d(n + k)) | å›ºå®šä½æ•°æ•´æ•° |
| æ¡¶æ’åº   | O(n + k)    | å‡åŒ€åˆ†å¸ƒ     |

**çªç ´ä¸‹ç•Œ**ï¼šéæ¯”è¾ƒæ’åºå¯ä»¥è¾¾åˆ° O(n)ï¼Œä½†æœ‰ç±»å‹é™åˆ¶ã€‚

### GPU æ’åºçš„é€‰æ‹©

**å¿«é€Ÿæ’åºä¸é€‚åˆ GPU**ï¼š

- é€’å½’æ·±åº¦ä¸ç¡®å®š
- åˆ†åŒºä¸å¹³è¡¡å¯¼è‡´è´Ÿè½½ä¸å‡
- æ•°æ®ä¾èµ–å¯¼è‡´åˆ†æ”¯å‘æ•£

**GPU å‹å¥½çš„ç®—æ³•**ï¼š

- **åŸºæ•°æ’åº**ï¼šè§„åˆ™çš„æ•°æ®è®¿é—®æ¨¡å¼ï¼Œåˆ©ç”¨å‰ç¼€å’Œ
- **å½’å¹¶æ’åº**ï¼šç¡®å®šçš„æ­¥éª¤æ•°ï¼Œå¯å¹¶è¡Œå½’å¹¶
- **åŒè°ƒæ’åº**ï¼šå®Œå…¨æ•°æ®æ— å…³çš„æ¯”è¾ƒç½‘ç»œ

## åŸºæ•°æ’åº

### æ ¸å¿ƒæ€æƒ³

æŒ‰ä½æ’åºï¼Œä»æœ€ä½ä½åˆ°æœ€é«˜ä½ï¼š

```
åŸå§‹:    [329, 457, 657, 839, 436, 720, 355]

æŒ‰ä¸ªä½æ’åºï¼ˆç¬¬0ä½ï¼‰:
         [720, 355, 436, 457, 657, 329, 839]

æŒ‰åä½æ’åºï¼ˆç¬¬1ä½ï¼‰:
         [720, 329, 436, 839, 355, 457, 657]

æŒ‰ç™¾ä½æ’åºï¼ˆç¬¬2ä½ï¼‰:
         [329, 355, 436, 457, 657, 720, 839]

å®Œæˆï¼
```

**å…³é”®**ï¼šæ¯ä¸€è½®æ’åºå¿…é¡»æ˜¯**ç¨³å®š**çš„ï¼Œä¿æŒç›¸åŒé”®å€¼å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚

### ä½æ’åºä¸è®¡æ•°æ’åº

æ¯ä¸€è½®æŒ‰æŸä¸€ä½æ’åºï¼Œä½¿ç”¨**è®¡æ•°æ’åº**ï¼š

```
1. ç»Ÿè®¡æ¯ä¸ªå€¼çš„å‡ºç°æ¬¡æ•°
2. è®¡ç®—å‰ç¼€å’Œå¾—åˆ°æ¯ä¸ªå€¼çš„èµ·å§‹ä½ç½®
3. æŒ‰åŸé¡ºåºåˆ†é…åˆ°è¾“å‡ºä½ç½®
```

å¯¹äºäºŒè¿›åˆ¶ä½ï¼ˆ0 æˆ– 1ï¼‰ï¼š

```
è¾“å…¥:    [1, 0, 1, 1, 0, 0, 1, 0]
è®¡æ•°:    count[0]=4, count[1]=4
å‰ç¼€å’Œ:  pos[0]=0, pos[1]=4
åˆ†é…:    è¾“å‡ºä½ç½® = pos[bit]++
ç»“æœ:    [0, 0, 0, 0, 1, 1, 1, 1]
```

### å¤šä½ä¸€èµ·å¤„ç†

ä¸€æ¬¡å¤„ç†å¤šä½ï¼ˆå¦‚ 4 ä½ï¼‰å¯ä»¥å‡å°‘è½®æ•°ï¼š

```
32 ä½æ•´æ•°:
  1 ä½/è½®: 32 è½®
  4 ä½/è½®: 8 è½®
  8 ä½/è½®: 4 è½®
```

ä»£ä»·æ˜¯æ¯è½®éœ€è¦æ›´å¤§çš„è®¡æ•°æ•°ç»„ï¼ˆ2^b ä¸ªæ¡¶ï¼‰ã€‚

## å¹¶è¡ŒåŸºæ•°æ’åº

### å• Block ç‰ˆæœ¬

```cuda
#define RADIX_BITS 4
#define RADIX (1 << RADIX_BITS)  // 16
#define RADIX_MASK (RADIX - 1)

__global__ void radix_sort_block(unsigned int *data, int n, int bit) {
    __shared__ unsigned int s_data[BLOCK_SIZE];
    __shared__ int s_count[RADIX];
    __shared__ int s_offset[RADIX];
    
    int tid = threadIdx.x;
    
    // åŠ è½½æ•°æ®
    s_data[tid] = (tid < n) ? data[tid] : 0xFFFFFFFF;
    __syncthreads();
    
    // ç»Ÿè®¡æ¯ä¸ªæ¡¶çš„è®¡æ•°ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…éœ€è¦åŸå­æˆ–è§„çº¦ï¼‰
    if (tid < RADIX) s_count[tid] = 0;
    __syncthreads();
    
    int digit = (s_data[tid] >> bit) & RADIX_MASK;
    atomicAdd(&s_count[digit], 1);
    __syncthreads();
    
    // å‰ç¼€å’Œå¾—åˆ°åç§»
    // ... exclusive scan on s_count â†’ s_offset ...
    
    // åˆ†é…åˆ°è¾“å‡ºä½ç½®
    int pos = atomicAdd(&s_offset[digit], 1);  // åŠ¨æ€åˆ†é…
    
    __shared__ unsigned int s_temp[BLOCK_SIZE];
    s_temp[pos] = s_data[tid];
    __syncthreads();
    
    // å†™å›
    s_data[tid] = s_temp[tid];
    __syncthreads();
    
    if (tid < n) data[tid] = s_data[tid];
}
```

### å¤§è§„æ¨¡åŸºæ•°æ’åº

å¯¹äºè¶…è¿‡å• Block çš„æ•°æ®ï¼Œéœ€è¦åˆ†é˜¶æ®µï¼š

**é˜¶æ®µ 1ï¼šå±€éƒ¨ç›´æ–¹å›¾**

æ¯ä¸ª Block ç»Ÿè®¡è‡ªå·±åŒºåŸŸçš„æ¡¶è®¡æ•°ã€‚

```cuda
__global__ void compute_histograms(unsigned int *data, int *histograms, 
                                    int n, int bit) {
    __shared__ int local_hist[RADIX];
    
    // åˆå§‹åŒ–
    if (threadIdx.x < RADIX) local_hist[threadIdx.x] = 0;
    __syncthreads();
    
    // ç»Ÿè®¡
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
        int digit = (data[i] >> bit) & RADIX_MASK;
        atomicAdd(&local_hist[digit], 1);
    }
    __syncthreads();
    
    // å†™å…¥å…¨å±€ç›´æ–¹å›¾
    if (threadIdx.x < RADIX) {
        histograms[blockIdx.x * RADIX + threadIdx.x] = local_hist[threadIdx.x];
    }
}
```

**é˜¶æ®µ 2ï¼šå‰ç¼€å’Œ**

å¯¹æ‰€æœ‰ Block çš„ç›´æ–¹å›¾åšå…¨å±€å‰ç¼€å’Œï¼Œå¾—åˆ°æ¯ä¸ª Block æ¯ä¸ªæ¡¶çš„å…¨å±€èµ·å§‹ä½ç½®ã€‚

```
Block 0 æ¡¶ k çš„èµ·å§‹ä½ç½® = Î£(Block < 0, æ¡¶ < k çš„è®¡æ•°) + Î£(Block < 0, æ¡¶ k çš„è®¡æ•°)
```

è¿™æ˜¯ä¸€ä¸ªäºŒç»´å‰ç¼€å’Œé—®é¢˜ã€‚

**é˜¶æ®µ 3ï¼šé‡æ’ï¼ˆScatterï¼‰**

æ ¹æ®è®¡ç®—å‡ºçš„ä½ç½®ï¼ŒæŠŠå…ƒç´ ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®ã€‚

```cuda
__global__ void scatter(unsigned int *in, unsigned int *out, 
                        int *prefix, int n, int bit) {
    __shared__ int local_prefix[RADIX];
    
    // åŠ è½½æœ¬ Block çš„å‰ç¼€
    if (threadIdx.x < RADIX) {
        local_prefix[threadIdx.x] = prefix[blockIdx.x * RADIX + threadIdx.x];
    }
    __syncthreads();
    
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
        int digit = (in[i] >> bit) & RADIX_MASK;
        int pos = atomicAdd(&local_prefix[digit], 1);
        out[pos] = in[i];
    }
}
```

### å®Œæ•´æµç¨‹

```cuda
void radix_sort(unsigned int *data, int n) {
    unsigned int *d_data, *d_temp;
    int *d_histograms, *d_prefix;
    
    int num_blocks = (n + BLOCK_SIZE - 1) / BLOCK_SIZE;
    
    cudaMalloc(&d_data, n * sizeof(unsigned int));
    cudaMalloc(&d_temp, n * sizeof(unsigned int));
    cudaMalloc(&d_histograms, num_blocks * RADIX * sizeof(int));
    cudaMalloc(&d_prefix, num_blocks * RADIX * sizeof(int));
    
    cudaMemcpy(d_data, data, n * sizeof(unsigned int), cudaMemcpyHostToDevice);
    
    for (int bit = 0; bit < 32; bit += RADIX_BITS) {
        // é˜¶æ®µ 1ï¼šè®¡ç®—ç›´æ–¹å›¾
        compute_histograms<<<num_blocks, BLOCK_SIZE>>>
            (d_data, d_histograms, n, bit);
        
        // é˜¶æ®µ 2ï¼šå…¨å±€å‰ç¼€å’Œ
        exclusive_scan(d_histograms, d_prefix, num_blocks * RADIX);
        
        // é˜¶æ®µ 3ï¼šé‡æ’
        scatter<<<num_blocks, BLOCK_SIZE>>>
            (d_data, d_temp, d_prefix, n, bit);
        
        // äº¤æ¢ç¼“å†²åŒº
        swap(d_data, d_temp);
    }
    
    cudaMemcpy(data, d_data, n * sizeof(unsigned int), cudaMemcpyDeviceToHost);
}
```

## ä¼˜åŒ–æŠ€æœ¯

### é¿å…åŸå­æ“ä½œ

é˜¶æ®µ 3 çš„ `atomicAdd` æ˜¯ç“¶é¢ˆã€‚å¯ä»¥ç”¨**æœ¬åœ°æ’åº + å‰ç¼€å’Œ**æ›¿ä»£ï¼š

```
1. æ¯ä¸ªçº¿ç¨‹å¤„ç†å¤šä¸ªå…ƒç´ 
2. æœ¬åœ°è®¡ç®—æ¯ä¸ªæ¡¶çš„å…ƒç´ ä¸ªæ•°
3. Block å†…å‰ç¼€å’Œå¾—åˆ°æ¯ä¸ªçº¿ç¨‹çš„èµ·å§‹åç§»
4. æ— å†²çªåœ°å†™å…¥è¾“å‡º
```

### å‘é‡åŒ–åŠ è½½

æ¯æ¬¡åŠ è½½ 4 ä¸ªå…ƒç´ ï¼š

```cuda
uint4 data4 = *reinterpret_cast<uint4*>(&data[i]);
// å¤„ç† data4.x, data4.y, data4.z, data4.w
```

å‡å°‘å†…å­˜äº‹åŠ¡æ•°ã€‚

### åˆ†æ¡¶ä¼˜åŒ–

å¯¹äºå¤§èŒƒå›´æ•°æ®ï¼Œå…ˆæŒ‰é«˜ä½åˆ†æˆå¤§æ¡¶ï¼Œå†åˆ†åˆ«æ’åºå°æ¡¶ï¼š

```
ç¬¬ä¸€éï¼šæŒ‰é«˜ 8 ä½åˆ†æˆ 256 ä¸ªæ¡¶
ç¬¬äºŒéï¼šå¯¹æ¯ä¸ªæ¡¶æŒ‰å‰©ä½™ 24 ä½æ’åº
```

å‡å°‘æ¯è½®éœ€è¦å¤„ç†çš„æ•°æ®é‡ã€‚

## å½’å¹¶æ’åº

### GPU å½’å¹¶æ’åºæµç¨‹

```
1. Block å†…æ’åºï¼ˆç”¨å…±äº«å†…å­˜ï¼‰
2. è·¨ Block å½’å¹¶ï¼ˆç”¨å¹¶è¡Œå½’å¹¶ï¼‰
```

**Block å†…æ’åº**å¯ä»¥ç”¨ï¼š

- æ¯”ç‰¹åºåˆ—æ’åºï¼ˆBitonic Sortï¼‰
- å¥‡å¶å½’å¹¶æ’åº
- ç›´æ¥å½’å¹¶æ’åº

### Block å†…æ’åº

```cuda
__global__ void block_sort(int *data, int n) {
    __shared__ int s_data[BLOCK_SIZE];
    
    int tid = threadIdx.x;
    int gid = blockIdx.x * blockDim.x + tid;
    
    // åŠ è½½
    s_data[tid] = (gid < n) ? data[gid] : INT_MAX;
    __syncthreads();
    
    // åŒè°ƒæ’åºï¼ˆBitonic Sortï¼‰
    for (int k = 2; k <= BLOCK_SIZE; k *= 2) {
        for (int j = k / 2; j > 0; j /= 2) {
            int ixj = tid ^ j;
            if (ixj > tid) {
                bool ascending = ((tid & k) == 0);
                if ((s_data[tid] > s_data[ixj]) == ascending) {
                    // äº¤æ¢
                    int temp = s_data[tid];
                    s_data[tid] = s_data[ixj];
                    s_data[ixj] = temp;
                }
            }
            __syncthreads();
        }
    }
    
    // å†™å›
    if (gid < n) data[gid] = s_data[tid];
}
```

### è·¨ Block å½’å¹¶

ä½¿ç”¨ç¬¬åäºŒç« çš„å¹¶è¡Œå½’å¹¶æŠ€æœ¯ï¼š

```cuda
void merge_sort_gpu(int *data, int n) {
    // é˜¶æ®µ 1ï¼šBlock å†…æ’åº
    int num_blocks = (n + BLOCK_SIZE - 1) / BLOCK_SIZE;
    block_sort<<<num_blocks, BLOCK_SIZE>>>(data, n);
    
    // é˜¶æ®µ 2ï¼šé€å±‚å½’å¹¶
    for (int width = BLOCK_SIZE; width < n; width *= 2) {
        int num_merges = (n + 2 * width - 1) / (2 * width);
        
        parallel_merge<<<num_merges, BLOCK_SIZE>>>(
            data, n, width);
    }
}
```

### å¤æ‚åº¦åˆ†æ

| é˜¶æ®µ       | å·¥ä½œé‡          | å¹¶è¡Œåº¦       |
| ---------- | --------------- | ------------ |
| Block æ’åº | O(n log B)      | n/B ä¸ª Block |
| å½’å¹¶ k å±‚  | O(n) Ã— log(n/B) | é€’å‡         |
| **æ€»è®¡**   | O(n log n)      |              |

## æ ·æœ¬æ’åºï¼ˆSample Sortï¼‰

### æ€æƒ³

1. **é‡‡æ ·**ï¼šä»æ•°æ®ä¸­éšæœºé€‰å–æ ·æœ¬
2. **æ’åºæ ·æœ¬**ï¼šå¾—åˆ°åˆ†å‰²ç‚¹ï¼ˆsplittersï¼‰
3. **åˆ†åŒº**ï¼šæ ¹æ®åˆ†å‰²ç‚¹æŠŠæ•°æ®åˆ†åˆ°ä¸åŒæ¡¶
4. **æ¡¶æ’åº**ï¼šæ¯ä¸ªæ¡¶ç‹¬ç«‹æ’åº
5. **åˆå¹¶**ï¼šæŒ‰é¡ºåºæ‹¼æ¥æ‰€æœ‰æ¡¶

### ä¼˜åŠ¿

- è´Ÿè½½å‡è¡¡æ›´å¥½ï¼ˆé‡‡æ ·ä¿è¯æ¡¶å¤§å°æ¥è¿‘ï¼‰
- å‡å°‘åŒæ­¥å¼€é”€ï¼ˆæ¡¶é—´ç‹¬ç«‹ï¼‰

### GPU å®ç°è¦ç‚¹

```cuda
void sample_sort(int *data, int n) {
    // 1. é‡‡æ ·
    int sample_size = min(n, 1024);
    sample_and_sort(data, n, samples, sample_size);
    
    // 2. é€‰æ‹©åˆ†å‰²ç‚¹
    int num_buckets = 256;
    select_splitters(samples, sample_size, splitters, num_buckets);
    
    // 3. åˆ†åŒº
    partition_to_buckets(data, n, splitters, bucket_ids, bucket_counts);
    
    // 4. å‰ç¼€å’Œå¾—åˆ°æ¡¶åç§»
    exclusive_scan(bucket_counts, bucket_offsets, num_buckets);
    
    // 5. é‡æ’åˆ°æ¡¶
    scatter_to_buckets(data, bucket_ids, bucket_offsets, temp, n);
    
    // 6. æ¡¶å†…æ’åº
    for (int b = 0; b < num_buckets; b++) {
        int start = bucket_offsets[b];
        int end = bucket_offsets[b + 1];
        sort_bucket<<<...>>>(temp + start, end - start);
    }
    
    // 7. æ‹·è´å›
    cudaMemcpy(data, temp, n * sizeof(int), cudaMemcpyDeviceToDevice);
}
```

## æ’åºç¨³å®šæ€§

### ä¸ºä»€ä¹ˆé‡è¦

**ç¨³å®šæ’åº**ï¼šç›¸åŒé”®å€¼çš„å…ƒç´ ä¿æŒåŸæœ‰çš„ç›¸å¯¹é¡ºåºã€‚

```
åŸå§‹:    [(3,'a'), (1,'b'), (3,'c'), (2,'d')]
æŒ‰æ•°å­—ç¨³å®šæ’åº:
         [(1,'b'), (2,'d'), (3,'a'), (3,'c')]
                          â†‘ 'a' ä»åœ¨ 'c' å‰é¢
```

**åº”ç”¨**ï¼š

- å¤šå…³é”®å­—æ’åºï¼ˆå…ˆæŒ‰æ¬¡å…³é”®å­—ï¼Œå†æŒ‰ä¸»å…³é”®å­—ï¼‰
- æ•°æ®åº“æ“ä½œï¼ˆä¿æŒæ’å…¥é¡ºåºï¼‰
- åŸºæ•°æ’åºçš„æ­£ç¡®æ€§ä¾èµ–ç¨³å®šæ€§

### GPU æ’åºçš„ç¨³å®šæ€§

| ç®—æ³•     | ç¨³å®šæ€§ |
| -------- | ------ |
| åŸºæ•°æ’åº | ç¨³å®š   |
| å½’å¹¶æ’åº | ç¨³å®š   |
| åŒè°ƒæ’åº | ä¸ç¨³å®š |
| å¿«é€Ÿæ’åº | ä¸ç¨³å®š |

åŸºæ•°æ’åºå¤©ç„¶ç¨³å®šï¼Œæ˜¯ GPU æ’åºçš„é¦–é€‰ã€‚

## CUB/Thrust åº“

### ä½¿ç”¨ Thrust

```cuda
#include <thrust/sort.h>
#include <thrust/device_vector.h>

void sortWithThrust(int *d_data, int n) {
    thrust::device_ptr<int> d_ptr(d_data);
    thrust::sort(d_ptr, d_ptr + n);
}

// ç¨³å®šæ’åº
thrust::stable_sort(d_ptr, d_ptr + n);

// æŒ‰é”®æ’åº
thrust::sort_by_key(d_keys, d_keys + n, d_values);
```

### ä½¿ç”¨ CUB

```cuda
#include <cub/cub.cuh>

void sortWithCub(unsigned int *d_data, int n) {
    void *d_temp = nullptr;
    size_t temp_bytes = 0;
    
    // ç¡®å®šä¸´æ—¶å­˜å‚¨å¤§å°
    cub::DeviceRadixSort::SortKeys(d_temp, temp_bytes, 
                                    d_data, d_data, n);
    
    cudaMalloc(&d_temp, temp_bytes);
    
    // æ‰§è¡Œæ’åº
    cub::DeviceRadixSort::SortKeys(d_temp, temp_bytes,
                                    d_data, d_data, n);
    
    cudaFree(d_temp);
}

// é”®å€¼å¯¹æ’åº
cub::DeviceRadixSort::SortPairs(d_temp, temp_bytes,
                                 d_keys, d_keys,
                                 d_values, d_values, n);
```

### æ€§èƒ½å¯¹æ¯”

ä»¥ 1 äº¿ä¸ª32ä½æ•´æ•°æ’åºä¸ºä¾‹ï¼š

| å®ç°            | æ—¶é—´   | ååé‡     |
| --------------- | ------ | ---------- |
| std::sort (CPU) | ~8 ç§’  | 50 Må…ƒç´ /s |
| Thrust sort     | ~30 ms | 3.3 Gå…ƒç´ /s |
| CUB RadixSort   | ~15 ms | 6.6 Gå…ƒç´ /s |

**æµ‹è¯•ç¯å¢ƒ**ï¼š
- CPUï¼šIntel i9-12900Kï¼ˆ16æ ¸ï¼‰
- GPUï¼šNVIDIA RTX 3090ï¼ˆ10496 CUDA æ ¸å¿ƒï¼Œ24GB æ˜¾å­˜ï¼‰
- æ•°æ®ï¼šéšæœºç”Ÿæˆçš„32ä½æ— ç¬¦å·æ•´æ•°

GPU æ’åºæ¯”å•æ ¸ CPU å¿« 500 å€ä»¥ä¸Šï¼Œæ¯”å¤šæ ¸ CPU å¿« 200 å€ä»¥ä¸Šã€‚

## æ€§èƒ½ä¼˜åŒ–æ€»ç»“

### ä¼˜åŒ–å±‚æ¬¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level 4: ç®—æ³•é€‰æ‹©                                â”‚
â”‚   - åŸºæ•°æ’åºï¼ˆæ•´æ•°æœ€å¿«ï¼‰                         â”‚
â”‚   - å½’å¹¶æ’åºï¼ˆé€šç”¨ç¨³å®šï¼‰                         â”‚
â”‚   - æ ·æœ¬æ’åºï¼ˆè´Ÿè½½å‡è¡¡ï¼‰                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Level 3: æ•°æ®å±€éƒ¨æ€§                              â”‚
â”‚   - Block å†…å…±äº«å†…å­˜æ’åº                         â”‚
â”‚   - å‘é‡åŒ–åŠ è½½/å­˜å‚¨                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Level 2: å‡å°‘åŒæ­¥                                â”‚
â”‚   - Warp å†…æ’åºæ— éœ€åŒæ­¥                          â”‚
â”‚   - å‡å°‘ Kernel å¯åŠ¨æ¬¡æ•°                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Level 1: åˆ©ç”¨å‰ç¼€å’Œ                              â”‚
â”‚   - é«˜æ•ˆçš„ç›´æ–¹å›¾å’Œåˆ†é…                           â”‚
â”‚   - é¿å…åŸå­æ“ä½œäº‰ç”¨                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é€‰æ‹©æŒ‡å—

| æ•°æ®ç±»å‹      | æ¨èç®—æ³•  |
| ------------- | --------- |
| 32 ä½æ•´æ•°     | åŸºæ•°æ’åº  |
| 64 ä½æ•´æ•°     | åŸºæ•°æ’åº  |
| æµ®ç‚¹æ•°        | åŸºæ•°æ’åº  |
| ç»“æ„ä½“/è‡ªå®šä¹‰ | å½’å¹¶æ’åº  |
| éœ€è¦ç¨³å®šæ€§    | åŸºæ•°/å½’å¹¶ |

æµ®ç‚¹æ•°éœ€è¦ç‰¹æ®Šå¤„ç†ç¬¦å·ä½å’ŒæŒ‡æ•°ã€‚

## å°ç»“

ç¬¬åä¸‰ç« ç³»ç»Ÿè®²è§£ GPU æ’åºï¼š

**åŸºæ•°æ’åº**ï¼šGPU ä¸Šæœ€å¿«çš„æ•´æ•°æ’åºã€‚æŒ‰ä½å¤„ç†ï¼Œåˆ©ç”¨å‰ç¼€å’Œç¡®å®šè¾“å‡ºä½ç½®ã€‚å¤šè½®ï¼ˆ32 ä½éœ€è¦ 8 è½® 4 ä½ï¼‰ä½†æ¯è½®é«˜åº¦å¹¶è¡Œã€‚

**ä¸‰é˜¶æ®µæµç¨‹**ï¼šç›´æ–¹å›¾ç»Ÿè®¡ â†’ å‰ç¼€å’Œè®¡ç®— â†’ å…ƒç´ é‡æ’ã€‚æ¯ä¸ªé˜¶æ®µéƒ½æ˜¯é«˜æ•ˆçš„å¹¶è¡Œæ“ä½œã€‚

**å½’å¹¶æ’åº**ï¼šé€šç”¨ä¸”ç¨³å®šã€‚Block å†…ç”¨åŒè°ƒæ’åºï¼Œè·¨ Block ç”¨å¹¶è¡Œå½’å¹¶ã€‚é€‚åˆä»»æ„å¯æ¯”è¾ƒç±»å‹ã€‚

**æ ·æœ¬æ’åº**ï¼šé€šè¿‡é‡‡æ ·å®ç°è´Ÿè½½å‡è¡¡ã€‚é€‚åˆæ•°æ®åˆ†å¸ƒä¸å‡åŒ€çš„æƒ…å†µã€‚

**ç¨³å®šæ€§**ï¼šåŸºæ•°æ’åºå¤©ç„¶ç¨³å®šï¼Œå¤šå…³é”®å­—æ’åºå’Œæ•°æ®åº“æ“ä½œå¿…éœ€ã€‚

**åº“ä¼˜å…ˆ**ï¼šCUB çš„ RadixSort é«˜åº¦ä¼˜åŒ–ï¼Œç”Ÿäº§ç¯å¢ƒç›´æ¥ä½¿ç”¨ã€‚ç†è§£åŸç†æœ‰åŠ©äºç‰¹æ®Šéœ€æ±‚çš„å®šåˆ¶ã€‚

æ’åºæ˜¯å¹¶è¡Œè®¡ç®—çš„è¯•é‡‘çŸ³ï¼ŒæŠŠå‰é¢å­¦çš„å½’çº¦ã€å‰ç¼€å’Œã€å½’å¹¶ç­‰æŠ€æœ¯ç»¼åˆè¿ç”¨ã€‚æŒæ¡ GPU æ’åºï¼Œå°±æŒæ¡äº†è¿™äº›åŸºç¡€åŸè¯­çš„å®æˆ˜åº”ç”¨ã€‚

---

## ğŸš€ ä¸‹ä¸€æ­¥

---

## ğŸ“š å‚è€ƒèµ„æ–™

- PMPP ç¬¬å››ç‰ˆ Chapter 13
- [ç¬¬åä¸‰ç« ï¼šæ’åº](https://smarter.xin/posts/d9ee9484/)

**å­¦ä¹ æ„‰å¿«ï¼** ğŸ“

---

> **æœ¬æ–‡ GitHub ä»“åº“**: [https://github.com/psmarter/PMPP-Learning](https://github.com/psmarter/PMPP-Learning)
