---
title: PMPP-ç¬¬å…«ç« ï¼šæ¨¡æ¿
tags:
  - CUDA
  - GPUç¼–ç¨‹
  - å¹¶è¡Œè®¡ç®—
  - PMPP
  - æ¨¡æ¿è®¡ç®—
  - Stencil
  - å…±äº«å†…å­˜
categories: çŸ¥è¯†åˆ†äº«
cover: /img/PMPP.jpg
abbrlink: 93c68d7a
date: 2026-01-17 17:15:06
---

## å‰è¨€

ç¬¬ä¸ƒç« å­¦ä¹ äº†å·ç§¯ï¼Œæœ¬ç« å­¦ä¹ æ¨¡æ¿è®¡ç®—ï¼ˆStencilï¼‰ã€‚è¿™ä¸¤è€…åœ¨è®¡ç®—æ¨¡å¼ä¸Šå¾ˆç›¸ä¼¼ï¼Œä½†ä¾§é‡ç‚¹ä¸åŒã€‚**å·ç§¯**å¼ºè°ƒä¿¡å·å¤„ç†ä¸­çš„æ»‘åŠ¨åŠ æƒå’Œï¼Œæƒé‡æ¥è‡ªæ»¤æ³¢å™¨ï¼›**æ¨¡æ¿è®¡ç®—**å¼ºè°ƒç§‘å­¦è®¡ç®—ä¸­çš„é‚»åŸŸæ›´æ–°ï¼Œå¸¸è§äºåå¾®åˆ†æ–¹ç¨‹ï¼ˆPDEï¼‰æ±‚è§£ã€ç‰©ç†ä»¿çœŸç­‰åœºæ™¯ã€‚ä» CUDA ä¼˜åŒ–è§’åº¦çœ‹ï¼Œä¸¤è€…çš„æŠ€æœ¯æ˜¯ç›¸é€šçš„ï¼Œä½†æ¨¡æ¿è®¡ç®—æœ‰å…¶ç‰¹ç‚¹ï¼šé€šå¸¸éœ€è¦**å¤šæ¬¡è¿­ä»£**ï¼Œå¿…é¡»å¤„ç†**æ—¶é—´æ­¥è¿›**å’Œ**åŒç¼“å†²**é—®é¢˜ã€‚

> **ğŸ“¦ é…å¥—èµ„æº**ï¼šæœ¬ç³»åˆ—æ–‡ç« é…æœ‰å®Œæ•´çš„ [GitHub ä»“åº“](https://github.com/psmarter/PMPP-Learning)ï¼ŒåŒ…å«æ¯ç« çš„ç»ƒä¹ é¢˜è§£ç­”ã€CUDA ä»£ç å®ç°å’Œè¯¦ç»†æ³¨é‡Šã€‚æ‰€æœ‰ä»£ç éƒ½ç»è¿‡æµ‹è¯•ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œã€‚

## æ¨¡æ¿è®¡ç®—åŸºç¡€

### ä»€ä¹ˆæ˜¯æ¨¡æ¿è®¡ç®—

æ¨¡æ¿è®¡ç®—ï¼ˆStencil Computationï¼‰ï¼šç”¨**å›ºå®šçš„é‚»åŸŸæ¨¡å¼**æ›´æ–°ç½‘æ ¼ä¸­çš„æ¯ä¸ªç‚¹ã€‚

**ä¸€ç»´çƒ­ä¼ å¯¼**ï¼ˆæœ€ç®€å•çš„ä¾‹å­ï¼‰ï¼š

```
æ—¶é—´ t:    [..., A, B, C, ...]
æ—¶é—´ t+1:       B' = (A + B + C) / 3
```

æ¯ä¸ªç‚¹çš„æ–°å€¼æ˜¯è‡ªå·±å’Œé‚»å±…çš„åŠ æƒå¹³å‡ã€‚è¿™å°±æ˜¯æ¨¡æ¿ï¼šä¸€ä¸ªæè¿°"å¦‚ä½•ä»é‚»å±…è®¡ç®—è‡ªå·±"çš„æ¨¡å¼ã€‚

### æ¨¡æ¿çš„å½¢çŠ¶

å¸¸è§çš„æ¨¡æ¿å½¢çŠ¶ï¼š

**1D ä¸‰ç‚¹æ¨¡æ¿**ï¼š

```
[ -1  0  +1 ]
   â†“  â†“  â†“
   A  B  C
```

**2D äº”ç‚¹æ¨¡æ¿ï¼ˆå†¯Â·è¯ºä¾æ›¼é‚»åŸŸï¼‰**ï¼š

```
       [0,-1]
         â†‘
[-1,0] â† [0,0] â†’ [+1,0]
         â†“
       [0,+1]
```

**2D ä¹ç‚¹æ¨¡æ¿ï¼ˆæ‘©å°”é‚»åŸŸï¼‰**ï¼š

```
[-1,-1] [0,-1] [+1,-1]
[-1, 0] [0, 0] [+1, 0]
[-1,+1] [0,+1] [+1,+1]
```

**3D ä¸ƒç‚¹æ¨¡æ¿**ï¼š

```
ä¸Šä¸‹å‰åå·¦å³ + è‡ªå·±
```

### æ¨¡æ¿ vs å·ç§¯

| ç‰¹æ€§     | å·ç§¯               | æ¨¡æ¿                |
| -------- | ------------------ | ------------------- |
| æƒé‡     | æ¥è‡ªæ»¤æ³¢å™¨ï¼Œä»»æ„å€¼ | é€šå¸¸æ˜¯å›ºå®šç³»æ•°      |
| è¿­ä»£     | é€šå¸¸å•æ¬¡           | å¤šæ¬¡æ—¶é—´æ­¥è¿›        |
| è¾¹ç•Œ     | é›¶å¡«å……å¸¸è§         | å‘¨æœŸ/å›ºå®šè¾¹ç•Œæ›´å¸¸è§ |
| åº”ç”¨     | ä¿¡å·/å›¾åƒå¤„ç†      | PDE/ç‰©ç†ä»¿çœŸ        |
| è¯»å†™æ¨¡å¼ | åªè¯»è¾“å…¥ï¼Œå†™è¾“å‡º   | è¯»æ—§å€¼ï¼Œå†™æ–°å€¼      |

ä» GPU ä¼˜åŒ–è§’åº¦ï¼Œä¸¤è€…çš„æ ¸å¿ƒæŠ€æœ¯æ˜¯ç›¸åŒçš„ï¼š**å¸¸é‡å†…å­˜**å­˜ç³»æ•°ï¼Œ**å…±äº«å†…å­˜** Tiling å‡å°‘å…¨å±€å†…å­˜è®¿é—®ã€‚

## 2D æ¨¡æ¿ï¼šçƒ­ä¼ å¯¼æ–¹ç¨‹

### ç‰©ç†èƒŒæ™¯

äºŒç»´çƒ­ä¼ å¯¼æ–¹ç¨‹ï¼š

$$
\frac{\partial T}{\partial t} = \alpha \left( \frac{\partial^2 T}{\partial x^2} + \frac{\partial^2 T}{\partial y^2} \right)
$$

ç”¨æœ‰é™å·®åˆ†ç¦»æ•£åŒ–åï¼š

$$
T_{i,j}^{n+1} = T_{i,j}^n + \alpha \Delta t \left( \frac{T_{i+1,j}^n + T_{i-1,j}^n + T_{i,j+1}^n + T_{i,j-1}^n - 4T_{i,j}^n}{\Delta x^2} \right)
$$

ç®€åŒ–ä¸ºäº”ç‚¹æ¨¡æ¿ï¼š

```
T_new[i][j] = c0 * T[i][j] + c1 * (T[i-1][j] + T[i+1][j] + T[i][j-1] + T[i][j+1])
```

å…¶ä¸­ `c0 = 1 - 4*alpha*dt/dxÂ²`ï¼Œ`c1 = alpha*dt/dxÂ²`ã€‚

### æœ´ç´ å®ç°

```cuda
__global__ void stencil_2d_basic(float *in, float *out, int N) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;
    
    if (i > 0 && i < N-1 && j > 0 && j < N-1) {
        out[i*N + j] = C0 * in[i*N + j] +
                       C1 * (in[(i-1)*N + j] + in[(i+1)*N + j] +
                             in[i*N + (j-1)] + in[i*N + (j+1)]);
    }
}
```

**é—®é¢˜**ï¼šæ¯ä¸ªç‚¹è¯»å– 5 æ¬¡å…¨å±€å†…å­˜ï¼Œç›¸é‚»ç‚¹çš„è®¿é—®æœ‰å¤§é‡é‡å ã€‚

### æ•°æ®å¤ç”¨åˆ†æ

è€ƒè™‘ä¸€è¡Œçº¿ç¨‹è®¡ç®—ï¼š

```
çº¿ç¨‹ j:   è¯»å– T[i][j-1], T[i][j], T[i][j+1], T[i-1][j], T[i+1][j]
çº¿ç¨‹ j+1: è¯»å– T[i][j], T[i][j+1], T[i][j+2], T[i-1][j+1], T[i+1][j+1]
                â†‘           â†‘ å…±äº«
```

ç›¸é‚»çº¿ç¨‹å…±äº«äº† `T[i][j]` å’Œ `T[i][j+1]`ã€‚å¦‚æœæŠŠä¸€ä¸ª Tile çš„æ•°æ®åŠ è½½åˆ°å…±äº«å†…å­˜ï¼Œè¿™äº›å…±äº«è®¿é—®éƒ½å˜æˆå¿«é€Ÿçš„ç‰‡ä¸Šè®¿é—®ã€‚

## Tiled æ¨¡æ¿å®ç°

### è¾“å…¥è¾“å‡º Tile å…³ç³»

ä¸å·ç§¯ç±»ä¼¼ï¼Œè®¡ç®— `OUT_TILE_SIZE Ã— OUT_TILE_SIZE` çš„è¾“å‡ºï¼Œéœ€è¦ `(OUT_TILE_SIZE + 2*r) Ã— (OUT_TILE_SIZE + 2*r)` çš„è¾“å…¥ã€‚

å¯¹äºäº”ç‚¹æ¨¡æ¿ï¼ˆr=1ï¼‰ï¼š

```
è¾“å…¥ Tileï¼š(T + 2) Ã— (T + 2)
è¾“å‡º Tileï¼šT Ã— T
```

### çº¿ç¨‹ä¸æ•°æ®æ˜ å°„

æœ‰ä¸¤ç§ç­–ç•¥ï¼š

**ç­–ç•¥ 1ï¼šçº¿ç¨‹æ•° = è¾“å…¥ Tile å¤§å°**

```
Block: (T+2) Ã— (T+2) çº¿ç¨‹
æ¯çº¿ç¨‹åŠ è½½ 1 ä¸ªè¾“å…¥å…ƒç´ 
åªæœ‰å†…éƒ¨ T Ã— T çº¿ç¨‹è®¡ç®—è¾“å‡º
```

**ç­–ç•¥ 2ï¼šçº¿ç¨‹æ•° = è¾“å‡º Tile å¤§å°**

```
Block: T Ã— T çº¿ç¨‹
éƒ¨åˆ†çº¿ç¨‹è´Ÿè´£åŠ è½½ Halo å…ƒç´ 
æ‰€æœ‰çº¿ç¨‹éƒ½è®¡ç®—è¾“å‡º
```

ä¹¦ä¸­æ¨è**ç­–ç•¥ 1**ï¼Œå› ä¸ºåŠ è½½æ›´ç®€å•ï¼Œä¸”è¾¹ç•Œçº¿ç¨‹è™½ä¸è®¡ç®—ä½†ä»èƒ½å¹¶è¡Œæ‰§è¡Œã€‚

### å®Œæ•´å®ç°

```cuda
#define IN_TILE_SIZE 18  // 16 + 2
#define OUT_TILE_SIZE 16

__global__ void stencil_2d_tiled(float *in, float *out, int N) {
    __shared__ float tile[IN_TILE_SIZE][IN_TILE_SIZE];
    
    // çº¿ç¨‹åœ¨è¾“å…¥ Tile ä¸­çš„ä½ç½®
    int tx = threadIdx.x, ty = threadIdx.y;
    
    // å¯¹åº”çš„å…¨å±€è¾“å…¥ä½ç½®
    int in_row = blockIdx.y * OUT_TILE_SIZE + ty - 1;  // -1 æ˜¯å› ä¸º Halo
    int in_col = blockIdx.x * OUT_TILE_SIZE + tx - 1;
    
    // åŠ è½½ï¼ˆå«è¾¹ç•Œæ£€æŸ¥ï¼‰
    if (in_row >= 0 && in_row < N && in_col >= 0 && in_col < N) {
        tile[ty][tx] = in[in_row * N + in_col];
    } else {
        tile[ty][tx] = 0.0f;  // è¾¹ç•Œå¤–å¡« 0
    }
    
    __syncthreads();
    
    // åªæœ‰å†…éƒ¨çº¿ç¨‹è®¡ç®—è¾“å‡º
    if (tx > 0 && tx < IN_TILE_SIZE - 1 && 
        ty > 0 && ty < IN_TILE_SIZE - 1) {
        
        int out_row = blockIdx.y * OUT_TILE_SIZE + ty - 1;
        int out_col = blockIdx.x * OUT_TILE_SIZE + tx - 1;
        
        if (out_row < N && out_col < N) {
            out[out_row * N + out_col] = 
                C0 * tile[ty][tx] +
                C1 * (tile[ty-1][tx] + tile[ty+1][tx] +
                      tile[ty][tx-1] + tile[ty][tx+1]);
        }
    }
}
```

### å¯åŠ¨é…ç½®

```cuda
dim3 block(IN_TILE_SIZE, IN_TILE_SIZE);  // 18Ã—18 = 324 çº¿ç¨‹
dim3 grid((N + OUT_TILE_SIZE - 1) / OUT_TILE_SIZE,
          (N + OUT_TILE_SIZE - 1) / OUT_TILE_SIZE);

stencil_2d_tiled<<<grid, block>>>(d_in, d_out, N);
```

### æ€§èƒ½åˆ†æ

| æŒ‡æ ‡       | æœ´ç´ å®ç°     | Tiled å®ç°        |
| ---------- | ------------ | ----------------- |
| æ¯è¾“å‡ºå…ƒç´  | 5 æ¬¡å…¨å±€è¯»å– | 18Â²/16Â² â‰ˆ 1.27 æ¬¡ |
| åŠ é€Ÿæ¯”     | 1Ã—           | ~4Ã—               |
| å…±äº«å†…å­˜   | 0            | 18Ã—18Ã—4 = 1.3 KB  |

## çº¿ç¨‹ç²—åŒ–ï¼ˆThread Coarseningï¼‰

### ä¸ºä»€ä¹ˆç²—åŒ–

Tiled æ¨¡æ¿æœ‰ä¸ªé—®é¢˜ï¼šè¾¹ç•Œçº¿ç¨‹åªåŠ è½½ä¸è®¡ç®—ï¼Œæ•ˆç‡ä¸é«˜ã€‚

```
Block çº¿ç¨‹æ•°ï¼š18Ã—18 = 324
è®¡ç®—çº¿ç¨‹æ•°ï¼š16Ã—16 = 256
åˆ©ç”¨ç‡ï¼š256/324 = 79%
```

å¦‚æœæ¨¡æ¿åŠå¾„æ›´å¤§ï¼Œåˆ©ç”¨ç‡æ›´ä½ã€‚

**çº¿ç¨‹ç²—åŒ–**çš„æ€è·¯ï¼šè®©æ¯ä¸ªçº¿ç¨‹è®¡ç®—å¤šä¸ªè¾“å‡ºå…ƒç´ ï¼Œåˆ†æ‘Šè¾¹ç•Œå¼€é”€ã€‚

### Z æ–¹å‘ç²—åŒ–

å¯¹äº 3D æ¨¡æ¿ï¼Œå¸¸ç”¨çš„æŠ€å·§æ˜¯åœ¨ Z æ–¹å‘å±•å¼€ï¼š

```cuda
#define IN_TILE_SIZE 18
#define OUT_TILE_SIZE 16
#define Z_COARSEN 8  // æ¯çº¿ç¨‹å¤„ç† 8 å±‚

__global__ void stencil_3d_coarsened(float *in, float *out, 
                                      int Nx, int Ny, int Nz) {
    __shared__ float tile[3][IN_TILE_SIZE][IN_TILE_SIZE];  // åªéœ€ 3 å±‚
    
    int tx = threadIdx.x, ty = threadIdx.y;
    int ox = blockIdx.x * OUT_TILE_SIZE + tx - 1;
    int oy = blockIdx.y * OUT_TILE_SIZE + ty - 1;
    
    // é¢„åŠ è½½å‰ä¸¤å±‚
    load_layer(tile[0], in, ox, oy, 0, Nx, Ny, Nz);
    load_layer(tile[1], in, ox, oy, 1, Nx, Ny, Nz);
    
    // æ»‘åŠ¨çª—å£éå† Z æ–¹å‘
    for (int z = 1; z < Nz - 1; z++) {
        // åŠ è½½ä¸‹ä¸€å±‚
        load_layer(tile[(z+1) % 3], in, ox, oy, z+1, Nx, Ny, Nz);
        __syncthreads();
        
        // è®¡ç®—å½“å‰å±‚
        if (tx > 0 && tx < IN_TILE_SIZE - 1 && 
            ty > 0 && ty < IN_TILE_SIZE - 1) {
            int idx = z * Nx * Ny + oy * Nx + ox;
            out[idx] = compute_stencil(tile, tx, ty, z);
        }
        __syncthreads();
    }
}
```

### å¯„å­˜å™¨ç²—åŒ–

æ›´æ¿€è¿›çš„åšæ³•ï¼šæŠŠæ»‘åŠ¨çª—å£å­˜åœ¨å¯„å­˜å™¨é‡Œï¼š

```cuda
__global__ void stencil_3d_register(float *in, float *out, 
                                     int Nx, int Ny, int Nz) {
    __shared__ float tile[IN_TILE_SIZE][IN_TILE_SIZE];
    
    int tx = threadIdx.x, ty = threadIdx.y;
    int ox = blockIdx.x * OUT_TILE_SIZE + tx - 1;
    int oy = blockIdx.y * OUT_TILE_SIZE + ty - 1;
    
    // å¯„å­˜å™¨å­˜ Z æ–¹å‘çš„ä¸‰ä¸ªå€¼
    float z_prev, z_curr, z_next;
    
    z_prev = load_element(in, ox, oy, 0, Nx, Ny, Nz);
    z_curr = load_element(in, ox, oy, 1, Nx, Ny, Nz);
    
    for (int z = 1; z < Nz - 1; z++) {
        z_next = load_element(in, ox, oy, z+1, Nx, Ny, Nz);
        
        // åŠ è½½ XY å¹³é¢åˆ°å…±äº«å†…å­˜
        tile[ty][tx] = z_curr;
        __syncthreads();
        
        // è®¡ç®—
        if (valid_output_thread) {
            out[idx] = C0 * tile[ty][tx] +
                       C1 * (tile[ty-1][tx] + tile[ty+1][tx] +
                             tile[ty][tx-1] + tile[ty][tx+1]) +
                       C2 * (z_prev + z_next);  // Z æ–¹å‘ç”¨å¯„å­˜å™¨
        }
        
        // æ»‘åŠ¨çª—å£
        z_prev = z_curr;
        z_curr = z_next;
        __syncthreads();
    }
}
```

**ä¼˜åŠ¿**ï¼šZ æ–¹å‘çš„è®¿é—®å®Œå…¨åœ¨å¯„å­˜å™¨ï¼Œæ— éœ€å…±äº«å†…å­˜ã€‚

## è¾¹ç•Œæ¡ä»¶å¤„ç†

### å¸¸è§è¾¹ç•Œæ¡ä»¶

**1. å›ºå®šè¾¹ç•Œï¼ˆDirichletï¼‰**

```cuda
if (is_boundary) {
    out[idx] = BOUNDARY_VALUE;  // å›ºå®šå€¼
}
```

**2. å‘¨æœŸè¾¹ç•Œï¼ˆPeriodicï¼‰**

```cuda
int wrapped_x = (x + N) % N;  // ç¯ç»•
int wrapped_y = (y + N) % N;
```

**3. é›¶æ¢¯åº¦è¾¹ç•Œï¼ˆNeumannï¼‰**

```cuda
// è¾¹ç•Œå¤„ç”¨ç›¸é‚»å†…éƒ¨å€¼
if (x == 0) x = 1;
if (x == N-1) x = N-2;
```

### è¾¹ç•Œå¤„ç†ç­–ç•¥

**æ–¹æ³• 1ï¼šæ¡ä»¶åˆ†æ”¯**

```cuda
if (i > 0 && i < N-1 && j > 0 && j < N-1) {
    // å†…éƒ¨ç‚¹è®¡ç®—
} else {
    // è¾¹ç•Œå¤„ç†
}
```

é—®é¢˜ï¼šåˆ†æ”¯å‘æ•£ã€‚

**æ–¹æ³• 2ï¼šå¡«å……ï¼ˆPaddingï¼‰**

é¢„å…ˆåœ¨æ•°æ®å‘¨å›´åŠ ä¸€åœˆè¾¹ç•Œå€¼ï¼Œæ ¸å‡½æ•°å†…éƒ¨æ— éœ€è¾¹ç•Œåˆ¤æ–­ã€‚

```
åŸå§‹æ•°æ® NÃ—N â†’ å¡«å……å (N+2)Ã—(N+2)
æ‰€æœ‰è®¡ç®—éƒ½åœ¨ [1, N] èŒƒå›´å†…
```

**æ–¹æ³• 3ï¼šåˆ†ç¦»è¾¹ç•Œæ ¸å‡½æ•°**

```cuda
// å…ˆå¤„ç†å†…éƒ¨åŒºåŸŸ
stencil_interior<<<blocks, threads>>>(in, out, N);

// å†å¤„ç†è¾¹ç•ŒåŒºåŸŸ
stencil_boundary<<<1, boundary_threads>>>(in, out, N);
```

å†…éƒ¨æ ¸å‡½æ•°æ— åˆ†æ”¯ï¼Œè¾¹ç•Œæ ¸å‡½æ•°çº¿ç¨‹å°‘ä½†é€»è¾‘å¤æ‚ã€‚

## æ—¶é—´æ­¥è¿›ä¸åŒç¼“å†²

### è¿­ä»£æ¨¡å¼

æ¨¡æ¿è®¡ç®—é€šå¸¸éœ€è¦å¤šæ¬¡è¿­ä»£ï¼š

```cuda
for (int t = 0; t < num_steps; t++) {
    stencil_kernel<<<grid, block>>>(d_in, d_out, N);
    cudaDeviceSynchronize();
    swap(d_in, d_out);  // äº¤æ¢è¾“å…¥è¾“å‡º
}
```

**å…³é”®**ï¼šä¸èƒ½åŸåœ°æ›´æ–°ï¼è¯»å–é‚»å±…æ—¶å¯èƒ½è¯»åˆ°å·²æ›´æ–°çš„å€¼ï¼Œå¯¼è‡´é”™è¯¯ã€‚æ‰€ä»¥éœ€è¦**åŒç¼“å†²**ï¼šè¯»æ—§å†™æ–°ï¼Œç„¶åäº¤æ¢ã€‚

### æ—¶é—´é˜»å¡ï¼ˆTemporal Blockingï¼‰

æ¯æ¬¡ kernel å¯åŠ¨æœ‰å¼€é”€ã€‚å¦‚æœèƒ½åœ¨ä¸€æ¬¡ kernel ä¸­è®¡ç®—å¤šä¸ªæ—¶é—´æ­¥ï¼Œå°±èƒ½å‡å°‘å¯åŠ¨å¼€é”€ã€‚

**åŸç†**ï¼š

```
è¾“å…¥ Tile è®¡ç®— T ä¸ªæ—¶é—´æ­¥ï¼š
æ—¶é—´ 0ï¼šéœ€è¦ (OUT + 2r*T) çš„è¾“å…¥
æ—¶é—´ 1ï¼šéœ€è¦ (OUT + 2r*(T-1)) çš„è¾“å…¥
...
æ—¶é—´ Tï¼šè¾“å‡º OUT çš„ç»“æœ
```

éšç€æ—¶é—´æ¨è¿›ï¼Œæœ‰æ•ˆæ•°æ®åŒºåŸŸå‘å†…æ”¶ç¼©ã€‚

**å®ç°å¤æ‚åº¦é«˜**ï¼Œé€šå¸¸åœ¨é«˜æ€§èƒ½è®¡ç®—åº“ä¸­ä½¿ç”¨ï¼Œæ‰‹å†™è¾ƒéš¾ã€‚

## 3D æ¨¡æ¿ä¼˜åŒ–

### æŒ‘æˆ˜

3D æ¨¡æ¿çš„å…±äº«å†…å­˜éœ€æ±‚æ›´å¤§ï¼š

```
2D: (T+2)Â² Ã— 4 = 324 Ã— 4 = 1.3 KB
3D: (T+2)Â³ Ã— 4 = 8000 Ã— 4 = 32 KB  // å¯èƒ½è¶…é™ï¼
```

### è§£å†³æ–¹æ¡ˆ

**1. å‡å° Tile å¤§å°**

```cuda
#define TILE_3D 8
// (8+2)Â³ = 1000 å…ƒç´ ï¼Œ4 KB
```

ä»£ä»·ï¼šé™ä½æ•°æ®å¤ç”¨ç‡ã€‚

**2. 2.5D åˆ†è§£**

åªåŠ è½½ XY å¹³é¢çš„ Tileï¼ŒZ æ–¹å‘é€å±‚å¤„ç†ï¼š

```cuda
__shared__ float tile[TILE_Y][TILE_X];  // åªå­˜ä¸€å±‚ XY

for (int z = 0; z < Nz; z++) {
    // åŠ è½½å½“å‰å±‚
    // è®¡ç®—ï¼ˆZ æ–¹å‘é‚»å±…ä»å…¨å±€å†…å­˜è¯»ï¼‰
}
```

Z æ–¹å‘çš„è®¿é—®ä»èµ°å…¨å±€å†…å­˜ï¼Œä½† XY æ–¹å‘åˆ©ç”¨å…±äº«å†…å­˜ã€‚

**3. å¯„å­˜å™¨æ»‘åŠ¨çª—å£**

å¦‚å‰æ‰€è¿°ï¼ŒZ æ–¹å‘ 3 ä¸ªå€¼å­˜å¯„å­˜å™¨ï¼ŒXY å¹³é¢å­˜å…±äº«å†…å­˜ã€‚

## æŒ‡ä»¤çº§ä¼˜åŒ–

### å¾ªç¯å±•å¼€

å¯¹äºå°æ¨¡æ¿ï¼Œæ‰‹åŠ¨å±•å¼€æ¶ˆé™¤å¾ªç¯å¼€é”€ï¼š

```cuda
// å±•å¼€å‰
for (int di = -1; di <= 1; di++) {
    for (int dj = -1; dj <= 1; dj++) {
        sum += tile[ty+di][tx+dj] * weight[di+1][dj+1];
    }
}

// å±•å¼€å
sum = tile[ty-1][tx-1] * W00 + tile[ty-1][tx] * W01 + tile[ty-1][tx+1] * W02 +
      tile[ty  ][tx-1] * W10 + tile[ty  ][tx] * W11 + tile[ty  ][tx+1] * W12 +
      tile[ty+1][tx-1] * W20 + tile[ty+1][tx] * W21 + tile[ty+1][tx+1] * W22;
```

ç¼–è¯‘å™¨é€šå¸¸ä¼šè‡ªåŠ¨å±•å¼€ï¼Œä½†æ˜¾å¼å±•å¼€ä¿è¯æ•ˆæœã€‚

### å¸¸é‡é¢„è®¡ç®—

```cuda
// ç¼–è¯‘æ—¶å¸¸é‡
#define C0 0.25f
#define C1 0.125f

// æˆ–ä½¿ç”¨ constexprï¼ˆC++11ï¼‰
__device__ constexpr float c0 = 0.25f;
```

é¿å…è¿è¡Œæ—¶è®¡ç®—ç³»æ•°ã€‚

### å‘é‡åŒ–åŠ è½½

å¯¹äºå¯¹é½çš„è®¿é—®æ¨¡å¼ï¼Œä½¿ç”¨å‘é‡ç±»å‹ï¼š

```cuda
float4 data = *reinterpret_cast<float4*>(&in[idx]);
// ä¸€æ¬¡åŠ è½½ 4 ä¸ª float
```

éœ€è¦æ•°æ®å¯¹é½ï¼ˆ16 å­—èŠ‚è¾¹ç•Œï¼‰ã€‚

## å®æˆ˜ï¼šJacobi è¿­ä»£æ±‚è§£å™¨

### é—®é¢˜è®¾ç½®

æ±‚è§£æ³Šæ¾æ–¹ç¨‹ âˆ‡Â²u = fï¼š

```cuda
// Jacobi è¿­ä»£ï¼šu_new = (u_left + u_right + u_up + u_down - hÂ²f) / 4
```

### CUDA å®ç°

```cuda
#define BLOCK_SIZE 16
#define TILE_SIZE 18  // BLOCK_SIZE + 2

__global__ void jacobi_iteration(float *u, float *u_new, float *f,
                                  int N, float h2) {
    __shared__ float tile[TILE_SIZE][TILE_SIZE];
    
    int tx = threadIdx.x + 1;  // åç§» 1ï¼Œç•™å‡º Halo
    int ty = threadIdx.y + 1;
    int gx = blockIdx.x * BLOCK_SIZE + threadIdx.x;
    int gy = blockIdx.y * BLOCK_SIZE + threadIdx.y;
    
    // åŠ è½½ä¸­å¿ƒ
    if (gx < N && gy < N) {
        tile[ty][tx] = u[gy * N + gx];
    }
    
    // åŠ è½½ Halo
    if (threadIdx.x == 0 && gx > 0) {
        tile[ty][0] = u[gy * N + gx - 1];
    }
    if (threadIdx.x == BLOCK_SIZE - 1 && gx < N - 1) {
        tile[ty][TILE_SIZE - 1] = u[gy * N + gx + 1];
    }
    if (threadIdx.y == 0 && gy > 0) {
        tile[0][tx] = u[(gy - 1) * N + gx];
    }
    if (threadIdx.y == BLOCK_SIZE - 1 && gy < N - 1) {
        tile[TILE_SIZE - 1][tx] = u[(gy + 1) * N + gx];
    }
    
    __syncthreads();
    
    // è®¡ç®—ï¼ˆè·³è¿‡è¾¹ç•Œï¼‰
    if (gx > 0 && gx < N - 1 && gy > 0 && gy < N - 1) {
        float f_val = f[gy * N + gx];
        u_new[gy * N + gx] = 0.25f * (tile[ty-1][tx] + tile[ty+1][tx] +
                                       tile[ty][tx-1] + tile[ty][tx+1] -
                                       h2 * f_val);
    }
}

// Host ç«¯è¿­ä»£
void jacobi_solve(float *u, float *f, int N, int max_iter, float tol) {
    float *d_u, *d_u_new, *d_f;
    // ... åˆ†é…å†…å­˜ ...
    
    dim3 block(BLOCK_SIZE, BLOCK_SIZE);
    dim3 grid((N + BLOCK_SIZE - 1) / BLOCK_SIZE,
              (N + BLOCK_SIZE - 1) / BLOCK_SIZE);
    
    for (int iter = 0; iter < max_iter; iter++) {
        jacobi_iteration<<<grid, block>>>(d_u, d_u_new, d_f, N, h*h);
        cudaDeviceSynchronize();
        
        // äº¤æ¢æŒ‡é’ˆ
        float *temp = d_u;
        d_u = d_u_new;
        d_u_new = temp;
        
        // å¯é€‰ï¼šæ£€æŸ¥æ”¶æ•›
    }
}
```

### æ”¶æ•›æ£€æŸ¥

æ¯éš”å‡ æ­¥æ£€æŸ¥æ®‹å·®ï¼š

```cuda
__global__ void compute_residual(float *u, float *f, float *residual,
                                  int N, float h2) {
    // è®¡ç®— ||âˆ‡Â²u - f||
    // ä½¿ç”¨è§„çº¦æ±‚å’Œ
}
```

ä¸éœ€è¦æ¯æ­¥éƒ½æ£€æŸ¥ï¼Œå¼€é”€å¤ªå¤§ã€‚

## æ€§èƒ½è°ƒä¼˜å»ºè®®

### Tile å¤§å°é€‰æ‹©

```
å…±äº«å†…å­˜é™åˆ¶ï¼š96 KB / SMï¼ˆAmpereï¼‰
æ¯ Block å¯ç”¨ï¼š~48 KB

2D Tile: sqrt(48K/4) â‰ˆ 110 â†’ å®é™…ç”¨ 32ã€48ã€64
3D Tile: cbrt(48K/4) â‰ˆ 23  â†’ å®é™…ç”¨ 8ã€12ã€16
```

éœ€è¦è€ƒè™‘å ç”¨ç‡ï¼šTile å¤ªå¤§å¯¼è‡´æ¯ SM çš„ Block æ•°å‡å°‘ã€‚

### Nsight æŒ‡æ ‡

å…³æ³¨ï¼š

| æŒ‡æ ‡                | æ„ä¹‰     | ç›®æ ‡     |
| ------------------- | -------- | -------- |
| Memory Throughput   | å¸¦å®½åˆ©ç”¨ | æ¥è¿‘å³°å€¼ |
| Compute Throughput  | è®¡ç®—åˆ©ç”¨ | è¶Šé«˜è¶Šå¥½ |
| Shared Memory Usage | å…±äº«å†…å­˜ | ä¸è¶…é™   |
| Warp Occupancy      | å ç”¨ç‡   | >50%     |

### å¸¸è§ç“¶é¢ˆ

**å¸¦å®½å—é™**ï¼šTiling ä¼˜åŒ–ã€å¯„å­˜å™¨ç¼“å­˜
**è®¡ç®—å—é™**ï¼šå‘é‡åŒ–ã€æŒ‡ä»¤çº§å¹¶è¡Œ
**å»¶è¿Ÿå—é™**ï¼šå¢åŠ å ç”¨ç‡ã€é¢„å–

## æ¨¡æ¿ä¼˜åŒ–æ€»ç»“

### æ ¸å¿ƒæŠ€æœ¯

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level 3: é«˜çº§ä¼˜åŒ–                                            â”‚
â”‚   - æ—¶é—´é˜»å¡ï¼ˆå¤šæ­¥åˆå¹¶ï¼‰                                      â”‚
â”‚   - è‡ªåŠ¨è°ƒä¼˜ï¼ˆæœç´¢æœ€ä¼˜å‚æ•°ï¼‰                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Level 2: æ•°æ®å±€éƒ¨æ€§                                          â”‚
â”‚   - å…±äº«å†…å­˜ Tiling                                          â”‚
â”‚   - å¯„å­˜å™¨æ»‘åŠ¨çª—å£                                           â”‚
â”‚   - çº¿ç¨‹ç²—åŒ–                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Level 1: åŸºç¡€ä¼˜åŒ–                                            â”‚
â”‚   - åŒç¼“å†²é¿å…ç«äº‰                                           â”‚
â”‚   - è¾¹ç•Œæ¡ä»¶å¤„ç†                                             â”‚
â”‚   - åˆå¹¶å†…å­˜è®¿é—®                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡æ¿ vs å·ç§¯å†³ç­–

| åœºæ™¯        | æ¨èæŠ€æœ¯          |
| ----------- | ----------------- |
| å•æ¬¡æ»¤æ³¢    | å·ç§¯ + å¸¸é‡å†…å­˜   |
| è¿­ä»£æ±‚è§£    | æ¨¡æ¿ + åŒç¼“å†²     |
| å¤§åŠå¾„æ¨¡æ¿  | æ—¶é—´é˜»å¡          |
| 3D + å¤§è§„æ¨¡ | 2.5D + å¯„å­˜å™¨æ»‘åŠ¨ |

## å°ç»“

ç¬¬å…«ç« å›´ç»•æ¨¡æ¿è®¡ç®—ï¼Œåœ¨ç¬¬ä¸ƒç« å·ç§¯çš„åŸºç¡€ä¸Šå¢åŠ äº†ï¼š

**è¿­ä»£ç»“æ„**ï¼šæ¨¡æ¿è®¡ç®—é€šå¸¸æ˜¯å¤šæ­¥è¿­ä»£çš„ã€‚åŒç¼“å†²æ˜¯åŸºæœ¬æŠ€å·§â€”â€”è¯»æ—§å†™æ–°ï¼Œç„¶åäº¤æ¢ã€‚

**çº¿ç¨‹ç²—åŒ–**ï¼šè®©æ¯ä¸ªçº¿ç¨‹è®¡ç®—å¤šä¸ªè¾“å‡ºï¼Œåˆ†æ‘Šè¾¹ç•Œçº¿ç¨‹çš„å¼€é”€ã€‚Z æ–¹å‘ç²—åŒ–æ˜¯ 3D æ¨¡æ¿çš„å¸¸ç”¨æŠ€å·§ã€‚

**å¯„å­˜å™¨ä¼˜åŒ–**ï¼šå¯¹äºæ»‘åŠ¨çª—å£æ¨¡å¼ï¼ŒæŠŠæ—¶é—´ç»´åº¦æˆ–ç©ºé—´ç»´åº¦çš„å°é‚»åŸŸå­˜å¯„å­˜å™¨ï¼Œæ¯”å…±äº«å†…å­˜æ›´å¿«ã€‚

**è¾¹ç•Œå¤„ç†**ï¼šDirichletã€Neumannã€å‘¨æœŸè¾¹ç•Œå„æœ‰ç­–ç•¥ã€‚Padding é¢„å¤„ç†èƒ½ç®€åŒ– kernel é€»è¾‘ï¼Œä½†éœ€è¦é¢å¤–å†…å­˜ã€‚

**3D æŒ‘æˆ˜**ï¼šå…±äº«å†…å­˜éœ€æ±‚çˆ†ç‚¸ã€‚2.5D åˆ†è§£ã€å¯„å­˜å™¨æ»‘åŠ¨æ˜¯è§£å†³æ–¹æ¡ˆã€‚

æ¨¡æ¿è®¡ç®—æ˜¯ç§‘å­¦è®¡ç®—çš„æ ¸å¿ƒï¼Œçƒ­ä¼ å¯¼ã€æµä½“åŠ›å­¦ã€ç”µç£ä»¿çœŸéƒ½ç”¨åˆ°ã€‚æŒæ¡è¿™å¥—ä¼˜åŒ–æŠ€æœ¯ï¼Œå°±èƒ½é«˜æ•ˆå®ç°å„ç§ PDE æ±‚è§£å™¨ã€‚ä¸‹ä¸€ç« è¿›å…¥å¦ä¸€ä¸ªé‡è¦æ¨¡å¼â€”â€”å¹¶è¡Œç›´æ–¹å›¾ã€‚

---

## ğŸš€ ä¸‹ä¸€æ­¥

---

## ğŸ“š å‚è€ƒèµ„æ–™

- PMPP ç¬¬å››ç‰ˆ Chapter 08
- [ç¬¬å…«ç« ï¼šæ¨¡æ¿](https://smarter.xin/posts/93c68d7a/)

**å­¦ä¹ æ„‰å¿«ï¼** ğŸ“

---

> **æœ¬æ–‡ GitHub ä»“åº“**: [https://github.com/psmarter/PMPP-Learning](https://github.com/psmarter/PMPP-Learning)
